// Copyright & License details are available under JXCORE_LICENSE file


// This is supposed to trigger iteration issues (if any) on objects with:
// for (var o in obj) {... }
// Object.prototype.doSomething = function(){};

var fs = require('fs');
var path = require("path");

var filesForDeletion = [];

exports.assert = require("./assert.js");

// true when app is stared with mt/mt-keep
exports.mted = false;
exports.mtkeeped = false;

for (var o in process.argv) {
  if (!process.argv.hasOwnProperty(o))
    continue;

  if (process.argv[o].slice(0, 7) == "mt-keep")
    exports.mtkeeped = true;

  if (process.argv[o].slice(0, 2) == "mt")
    exports.mted = true;
}

exports.rmdirSync = function (fullDir) {

  fullDir = path.normalize(fullDir);
  if (!fs.existsSync(fullDir)) {
    return;
  }

  var cmd = "rm -rf ";
  if (process.platform === 'win32') cmd = "rmdir /s /q ";
  if (process.platform === 'android') cmd = "rm -r "; // no -f allowed
  jxcore.utils.cmdSync(cmd + fullDir);
};

/**
 * Calls system command to remove file/files (which can given as a mask e.g. *.log)
 * @param fileOrMask
 */
exports.rmfilesSync = function (fileOrMask) {

  var isMask = fileOrMask.indexOf("*") !== -1 || fileOrMask.indexOf("?") !== -1;

  if (!isMask) {
    fileOrMask = path.normalize(fileOrMask);
    if (!fs.existsSync(fileOrMask))
      return;
  }

  var cmd = "rm -f ";
  if (process.platform === 'win32') cmd = "del /q ";
  if (process.platform === 'android') cmd = "rm ";  // no -f allowed

  jxcore.utils.cmdSync(cmd + fileOrMask);
};

exports.copyFileSync = function (src, dest) {

  src = path.normalize(src);
  dest = path.normalize(dest);
  if (!fs.existsSync(src)) {
    return;
  }

  fs.writeFileSync(dest, fs.readFileSync(src));
};


/**
 * If src is a file, than copies it to dest.
 * If src is a folder, than copies it to dest recursively.
 * @param src
 * @param dest
 */
exports.copySync = function (src, dest) {

  src = path.normalize(src);
  dest = path.normalize(dest);
  if (!fs.existsSync(src)) {
    return;
  }

  var stats = fs.statSync(src);
  if (stats.isFile()) {
//        console.log("Copying file to " + dest);
    fs.writeFileSync(dest, fs.readFileSync(src));
    return;
  }

  if (stats.isDirectory()) {
//        console.log("Copying folder to " + dest);
    var files = fs.readdirSync(src);

    if (!files.length) {
      return;
    }

    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest);
    }

    for (var a in files) {
      if (!files.hasOwnProperty(a))
        continue;
      var srcFile = src + path.sep + files[a];
      var dstFile = dest + path.sep + files[a];
      var stats = fs.statSync(srcFile);

      if (stats.isDirectory()) {
        exports.copySync(srcFile, dstFile);
      } else {
        fs.writeFileSync(dstFile, fs.readFileSync(srcFile));
      }
    }
  }
};


/**
 * Useful for app with tasks. Main process needs time to exit when a task was added (even if it was finished).
 * So we can try to force faster exit, just for faster tests processing.
 */
exports.exitNow = function () {

  return;
  if (process.threadId === -1) {
    // main thread;
    //process.exit();
    setTimeout(process.exit, 10);
    return;
  }
};


/**
 * mt/mt-keep exits are slow, so we can try to force faster exit, just for faster tests processing.
 * But still we exit ONLY when all of the other threads already called it.
 * BEWARE, process.on('exit') may not be called for all threads, so don't use the method below if you rely on process.on('exit').
 *
 * You can safely disable this method by calling return at the beginning.
 */
exports.exitNowMT = function () {

  return;
  //console.log("mted", exports.mted);
  if (!exports.mted) return;

  jxcore.store.shared.set("mtkeep-thread" + process.threadId, "ok");

  var all = true;
  for (var a = 0; a < jxcore.tasks.getThreadCount(); a++) {
    if (!jxcore.store.shared.exists("mtkeep-thread" + a)) {
      all = false;
      break;
    }
  }

  if (all) {
    //console.log("All threads done. Exiting");
    process.exit();
  }
};


/**
 * Instead of throwing error writes it into console and exist with exitCode = 1
 * This is mostly for mt app, which restart the thread on throw instead of exit the test.
 * @param err
 */
exports.throwMT = function (err) {

  if (process.threadId == -1) {
    throw err;
    return;
  }

  if (err) {
    console.error("throwMT:");
    console.error("\t", err);
  }

  process.exit(1);
};

exports.gotSignal = null;

/**
 * Catches signals and prevents process termination
 * allowing for process.on('exit') to be invoked.
 */
exports.listenForSignals = function() {
  var onSignal = function(signal) {
    exports.gotSignal = signal;
    jxcore.utils.console.warn("Got signal", signal);
  };

  process.on('SIGTERM', function() { onSignal('SIGTERM'); });
  process.on('SIGBREAK', function() { onSignal('SIGBREAK'); });
  process.on('SIGINT', function() { onSignal('SIGINT'); });
  process.on('SIGHUP', function() { onSignal('SIGHUP'); });
};


/**
 * Save a given script into batch file and returns it's file name
 * No need to delete it afterwards, since it should be performed in process.on('exit')
 * @param script
 * @return {string}
 */
exports.saveBatchFile = function(script) {
  var fname = require.main.filename + "_batch_" + jxcore.utils.uniqueId();
  fname += (process.platform === "win32") ? ".bat" : ".sh";
  fs.writeFileSync(fname, script);
  fs.chmodSync(fname, "755");
  filesForDeletion.push(fname);
  return fname;
};


process.on('exit', function() {

  for(var a = 0, len = filesForDeletion.length; a < len; a++) {
    try {
      fs.unlinkSync(filesForDeletion[a]);
    } catch (ex) {}
  }
});

/**
 * calls monitor and gets log: http://localhost:17777/log?silent
 * @param cb
 */
exports.getMonitorLog = function (cb) {
  var options = {
    host: 'localhost',
    port: 17777,
    path: '/logs?silent'
  };

  require("http").get(options, function (res) {
    res.setEncoding('utf8');

    var body = "";

    res.on('data', function (chunk) {
      body += chunk;
    });

    res.on('end', function() {
      cb(false, body);
    });

  }).on("error", function (err) {
    cb(true, err);
  });
};


exports.addFilesForDeletion = function() {
  for(var o in arguments) {
    if (arguments.hasOwnProperty(o))
      filesForDeletion.push(arguments[o]);
  }
};